<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetVND.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">LDH-FINAL</a> &gt; <a href="index.source.html" class="el_package">main.java</a> &gt; <span class="el_source">MetVND.java</span></div><h1>MetVND.java</h1><pre class="source lang-java linenums">package main.java;


import java.util.Arrays;



/**
 * @class MetVND
 * @brief Implementa la heurística de Descenso del Vecindario Variable (VND) para problemas de optimización en grafos.
 */
public class MetVND {
    /**
     * Representación del grafo donde se realizará la optimización.
     */
    private Grafo grafo;

    /**
     * Solución construida que será mejorada mediante VND.
     */
    private int[] solConstruida;

    /**
     * Constructor de la clase.
     * @param G El grafo sobre el cual se aplicará VND.
     * @param solucaoConstruida Solución inicial sobre la cual se mejorará.
     */
<span class="fc" id="L28">    public MetVND(Grafo builtGrafo, int[] solucaoConstruida) {</span>
<span class="fc" id="L29">        this.grafo = builtGrafo;</span>
<span class="fc" id="L30">        this.solConstruida = solucaoConstruida;</span>
<span class="fc" id="L31">    }</span>

    /**
     * Método principal que ejecuta el proceso de VND.
     * @return Retorna la mejor solución vecina encontrada.
     */
    public int[] run(){
<span class="fc" id="L38">        int[] melhorVizinho = this.solConstruida;</span>
        int[] sTemp;
<span class="fc" id="L40">        int r = 2;</span>
<span class="fc" id="L41">        int k = 1;</span>

<span class="fc bfc" id="L43" title="All 2 branches covered.">        while (k &lt;= r){</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">            if (k == 1){</span>
<span class="fc" id="L45">                sTemp = explorarSwap(melhorVizinho);</span>
            }else{
<span class="fc" id="L47">                sTemp = explorarDoisOpt(melhorVizinho);</span>
            }

<span class="pc bpc" id="L50" title="1 of 2 branches missed.">            if (valorSol(sTemp) &lt; valorSol(melhorVizinho)){</span>
<span class="nc" id="L51">                melhorVizinho = sTemp;</span>
<span class="nc" id="L52">                k = 1;</span>
            }else{
<span class="fc" id="L54">                ++k;</span>
            }
        }

<span class="fc" id="L58">        return melhorVizinho;</span>
    }

    /**
     * Calcula el valor de la solución dada.
     * @param s Array que representa la solución cuyo valor será calculado.
     * @return Retorna el valor total de la solución.
     */
    public double valorSol(int[] s) {
<span class="fc" id="L67">        double solucao = 0;</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">        for (int c = 1; c &lt; s.length; ++c) {</span>
<span class="fc" id="L69">            solucao += grafo.getAresta(s[c-1], s[c]).getPeso();</span>
        }
<span class="fc" id="L71">        solucao += grafo.getAresta(s[s.length-1], s[0]).getPeso();</span>

<span class="fc" id="L73">        return solucao;</span>
    }

    /**
     * Explora el vecindario mediante el intercambio de posiciones (swap) entre dos vértices.
     * @param s Solución actual.
     * @return Retorna la mejor solución vecina encontrada por swap.
     */
    private int[] explorarSwap(int[] s){
<span class="fc" id="L82">        int[] bestV = s;</span>
        int[] sAux;
<span class="fc" id="L84">        double melhorSolucao = valorSol(s);</span>

<span class="fc bfc" id="L86" title="All 2 branches covered.">        for (int c = 0; c &lt; s.length; ++c){</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">            for (int k = c+1; k &lt; s.length; ++k){</span>
<span class="fc" id="L88">                sAux = swap(c, k, s);</span>

<span class="pc bpc" id="L90" title="1 of 2 branches missed.">                if (valorSol(sAux) &lt; melhorSolucao){</span>
<span class="nc" id="L91">                    melhorSolucao = valorSol(sAux);</span>
<span class="nc" id="L92">                    bestV = sAux;</span>
                }
            }
        }

<span class="fc" id="L97">        return bestV;</span>
    }

    /**
     * Explora el vecindario utilizando la heurística 2-opt.
     * @param s Solución actual.
     * @return Retorna la mejor solución vecina encontrada por 2-opt.
     */
    private int[] explorarDoisOpt(int[] s){
<span class="fc" id="L106">        int[] bestViz = s;</span>
        int[] sAux;
<span class="fc" id="L108">        double bestSol = valorSol(s);</span>

<span class="fc bfc" id="L110" title="All 2 branches covered.">        for (int c = 0; c &lt; s.length; ++c){</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">            for (int k = c+1; k &lt; s.length; ++k){</span>
<span class="fc" id="L112">                sAux = doisOpt(c, k, s);</span>

<span class="pc bpc" id="L114" title="1 of 2 branches missed.">                if (valorSol(sAux) &lt; bestSol){</span>
<span class="nc" id="L115">                    bestSol = valorSol(sAux);</span>
<span class="nc" id="L116">                    bestViz = sAux;</span>
                }
            }
        }

<span class="fc" id="L121">        return bestViz;</span>
    }

    /**
     * Intercambia dos vértices en la solución dada.
     * @param i Índice del primer vértice a intercambiar.
     * @param j Índice del segundo vértice a intercambiar.
     * @param s Solución actual.
     * @return Retorna la solución con los dos vértices intercambiados.
     */
    private int[] swap(int i, int j, int[] s){
<span class="fc" id="L132">        int[] arrayAux = s.clone();</span>
<span class="fc" id="L133">        int aux = arrayAux[i];</span>
<span class="fc" id="L134">        arrayAux[i] = arrayAux[j];</span>
<span class="fc" id="L135">        arrayAux[j] = aux;</span>

<span class="fc" id="L137">        return arrayAux;</span>
    }

    /**
     * Aplica la heurística 2-opt para invertir un segmento de la solución.
     * @param i Índice inicial del segmento a invertir.
     * @param j Índice final del segmento a invertir.
     * @param s Solución actual.
     * @return Retorna la solución con el segmento invertido.
     */
    private int[] doisOpt(int i, int j, int[] s){
        int[] subArray;
<span class="fc" id="L149">        int[] sAux = s.clone();</span>
<span class="fc" id="L150">        int count = 0;</span>

<span class="fc" id="L152">        subArray = Arrays.copyOfRange(sAux, i, j+1);</span>
<span class="fc" id="L153">        inverterArray(subArray);</span>

<span class="fc bfc" id="L155" title="All 2 branches covered.">        for (int k = i; k &lt;= j; ++k){</span>
<span class="fc" id="L156">            sAux[k] = subArray[count];</span>
<span class="fc" id="L157">            ++count;</span>
        }
<span class="fc" id="L159">        return sAux;</span>
    }

    /**
     * Invierte un array dado.
     * @param a El array que será invertido.
     */
    private void inverterArray(int[] a){
<span class="fc" id="L167">        int count = 0;</span>
<span class="fc" id="L168">        int[] aux = a.clone();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        for (int i = a.length-1; i &gt;= 0; --i){</span>
<span class="fc" id="L170">            a[i] = aux[count];</span>
<span class="fc" id="L171">            ++count;</span>
        }
<span class="fc" id="L173">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>